# -*- coding: utf-8 -*-
"""
Created on Mon Jul 12 16:06:00 2021

@author: kazuk
"""

# O(EV)
#edgeは(from, to, cost)の順で情報を持った辺のリスト
#nは頂点数
n, m = map(int, input().split())
edge = []
for _ in range(m):
    f, t, c = map(int, input().split())
    f -= 1
    t -= 1
    edge.append((f, t, c))
    
def bellman_ford(s, edge, n):
    dist = [float('inf')]*n # 各頂点への最小コスト
    dist[s] = 0 # 自身への距離は0
    for i in range(n):
        update = False # 更新が行われたか
        for f, t, cost in edge:
            if dist[t] > dist[f] + cost:
                dist[t] = dist[f] + cost
                update = True
        if not update:
            break
        # 負閉路が存在(n回の更新)
        #(for分の内側なのでn回目の更新があればここまで来ない)
        if i == n-1:
            return False
    return dist


"""
グラフの頂点数をV,辺の数をEとする。
各頂点への最小コストを記録するリストddを作成する。
ここで、自身の点への距離は0で確定、他の点への距離はINFとする。
　ここから、辺をすべて見て最短距離を更新していく。
 具体的に、辺eが頂点fromから頂点toに向けてコストcostという情報を持つとすると、
d[from]+cost<d[to]
d[from]+cost<d[to]

となるとき、d[to]d[to]の値がd[from]+costd[from]+costに更新される。
　すべての辺を見るという操作を合計V−1V−1回行えば、
 負閉路がない場合にはすべての最小コストが確定する。
 つまり、V回目においてまだ最小コストの更新が行われた場合には負閉路を持つということで、正しい最小コストは求められない。
　では、なぜV−1V−1回のループで操作を完了させていいのか。
 自分の理解の仕方を説明する。ある頂点への最小コストとなる経路の中に、同じ頂点は2度と含まれない。
 含まれるとしたら負閉路があるということでそもそも正しい経路は求まらない。
 以上より、ある頂点への最短経路に含まれる辺の数は最大でもV−1本である。
 この後のコードを確認すれば分かるのだが、辺の並びは入力順である。(幅優先探索のように近い順に調べるわけではない)つまり、V−1V−1本の最短経路を求める過程を考える。うまくいけば1回のループで前から順に辺が辿られ、この最短経路が求まるかもしれない。しかし、調べる辺の順がきれいに後ろから並んでしまっているとする。この時、前の辺が調べられていないとそれより後ろの辺を最短経路の一部とは考えられない。(fromfromまでの距離がINFもしくは最小コストではないため)つまり、このケースでは1回のループにつきこの最短経路のうち前から1つずつしか求まらない。よって、これが最悪のケースで、V−1V−1回のループを必要とする。
 """