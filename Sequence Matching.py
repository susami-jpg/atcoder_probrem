# -*- coding: utf-8 -*-
"""
Created on Sun Jul 11 15:02:46 2021

@author: kazuk
"""

n, m = map(int, input().split())
a = [0] + list(map(int, input().split()))
b = [0] + list(map(int, input().split()))
inf = 1000000000
#dp[i][j]: aをi番目までbをj番目まで見た時のx+yの最小値
dp = [[inf] * (m + 1) for _ in range(n + 1)]
dp[0][0] = 0
for i in range(1, n+1):
    dp[i][0] = i
for j in range(1, m+1):
    dp[0][j] = j
    
for i in range(1, n + 1):
    for j in range(1, m + 1):
        #a[i]かb[j]を取り除く場合
        dp[i][j] = min(dp[i][j], dp[i][j-1] + 1, dp[i-1][j] + 1)
        #a[i]とb[j]を残す場合
        diff = a[i] != b[j] #同じなら0、違うなら1
        dp[i][j] = min(dp[i][j], dp[i-1][j-1] + diff)
        #両方取り除く場合は両方残す場合（+0 or +1)と比較して常に不利(+2)なので考えなくてよい
        
print(dp[n][m])


"""
LCS（最長共通部分列）と同じような問題設定なので、DP（動的計画法）を使う。具体的には以下のようにdpを定める。iとjは1-indexed。

dp[i][j]：Aがi番目まで、Bがj番目までしかないとした場合のx+yの最小値
つまり、任意のiとjについて、dp[i][j]におけるA'とB'の長さは等しくなっている。dp[i][j]への遷移元としてはdp[i-1][j]、dp[i][j-1]、dp[i-1][j-1]の3パターンが考えられる。
dp[i-1][j]のケースを考えてみると、当然dp[i-1][j]の状態でもA'とB'の長さは等しいので、ここからdp[i][j]に遷移するときにAのi番目（Ai）を追加することはできない（Aiを追加すると、dp[i][j]におけるA'がB'よりも1長くなってしまうため）。したがって、dp[i-1][j]からdp[i][j]に遷移する際は、xの値を1増やしてAiを削除するしか選択肢はない。
同様にdp[i][j-1]についても、dp[i][j-1]からdp[i][j]に遷移する際はxの値を1増やしてBのj番目（Bj）を削除するしか選択肢はない。
最後にdp[i-1][j-1]のケースでは、まずAiとBjのいずれか一方だけを選ぶとdp[i][j]に遷移後のA'とB'の長さが違ってしまうため、いずれも選択するかいずれも削除するかの二つの方法だけを考えればよい。いずれも選択する場合、AiとBjが同じであれば、xもyも増えることはない。AiとBjが違っていたら、xは増えないがyが1増える。AiとBjのいずれも選択しない場合、yは増えないがxが2増えることになる。先程のAiとBjのいずれも選択する場合はx+yの値は高々1しか増えないので、x+yの値を2増やしてAiとBjのいずれも削除する方法を取る必要は絶対にないことがわかる。

以上より、dp[i][j]を決める際は以下の3種類の中の最小値を選べばよい。
・dp[i-1][j] + 1
・dp[i][j-1] + 1
・dp[i-1][j-1] + unmatch_flag（AiとBjが同じなら0、違えば1）

dpの初期化については、iが0でjが0以上のときはA'とB'を同じ長さにするためにBをj文字全て削除するしかなく、x+y=j+0=jなのでdp[0][j]=jとなる。iが0以上でjが0のときも同様にdp[i][0]=iとなる。
"""
